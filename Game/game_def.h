//
//  game_def.h
//  Chaos Chess (Hummingbird)
//
//  Created by McKinley Keys on 1/10/22.
//

#pragma once
#ifndef game_def_h
#define game_def_h

#include "fruit.h"
#include "definitions.h"
#include "variants.h"
#include "table.h"
#include <memory>

class AbstractGame
{
public:
	
	Color active_player;
	
	Bitboard EN_PASSANT;
	CastlingRights castling_rights;
	
	Bitboard PIECES[PIECE_COUNT];
	Bitboard PLAYERS[2];
	Bitboard OCCUPIED;
	Piece list[64];
	
	std::vector<Move> move_history;
	std::vector<CastlingRights> castling_rights_history;
	std::vector<Bitboard> EN_PASSANT_HISTORY;
	std::vector<HashKey> hash_history;
	std::vector<int> reversible_move_clock_history;
	
	// These vectors will only be used for variants that have destructive moves
	std::vector<std::array<Bitboard, PIECE_COUNT>> PIECES_HISTORY;
	std::vector<std::array<Bitboard, 2>> PLAYERS_HISTORY;
	std::vector<std::array<Piece, 64>> list_history;
	
	//	std::multiset<HashKey> all_previous_positions;
	/// The number of half-moves since the last "irreversible" move was made.
	int reversible_move_clock;
	bool fifty_move_rule_enabled = true;
	
	HashKey hash;
	
	/// Returns a pointer to a new instance of `Game<variant>`.
	static std::unique_ptr<AbstractGame> instantiate(Variant variant);
	/// Returns a pointer to a copy of this game.
	virtual std::unique_ptr<AbstractGame> clone() const = 0;
	
	virtual ~AbstractGame() = default;
	
	virtual void clear() = 0;
	virtual void default_setup() = 0;
	virtual void setup_fen(const std::string &fen) = 0;
	virtual void setup_visual(const std::string &visual) = 0;
	
	virtual std::string fen() const = 0;
	virtual std::string debug_description() const = 0;
	virtual void display(const std::string &label = "") const = 0;
	virtual std::string visual() const = 0;
	
	/// Does not take the fifty move rule or three-move repetition rule into account.
	virtual std::vector<Move> legal_moves() = 0;
	
	/// Returns whether `player` is in check.
	virtual bool is_check(Color player) const = 0;
	/// Returns whether the active player is in checkmate.
	virtual bool is_checkmate() = 0;
	virtual bool is_win(Color player) = 0;
	virtual bool is_stalemate() = 0;
	virtual bool is_draw() = 0;
	virtual bool is_finished() = 0;
	
	virtual void apply(Move move) = 0;
	virtual void undo() = 0;
	
	/// Attempts to parse a move from universal notation, returning `NULL_MOVE` if the string is invalid.
	virtual Move try_parse_universal(const std::string &universal) const = 0;
	/// Attempts to parse a move from universal notation, crashing with an error message if the string is invalid. Prefer to use this method over `try_parse_universal` unless you are specifically checking whether the string is valid.
	virtual Move parse_universal(const std::string &universal) const = 0;
	virtual std::string universal_notation(Move move) const = 0;
	
	virtual Move parse_algebraic(const std::string &algebraic) const = 0;
	
	
	// MARK: - UI Helpers
	
	/// Returns the locations of all pieces that are captured by `move`.
	virtual std::vector<int> captured_pieces(Move move) const = 0;
};


template<Variant V>
class Game: public AbstractGame
{
public:
	
	/// All quasi-legal moves. Generated by `generate_quasilegal_moves()`.
	mutable std::vector<Move> quasilegal_moves;
	
	Game();
	
	std::unique_ptr<AbstractGame> clone() const;
	
	void clear();
	void set(int square, Piece piece, Color player);
	void set(const std::string &algebraic, Piece piece, Color player);
	void default_setup();
	void setup_fen(const std::string &fen);
	void setup_visual(const std::string &visual);
	void sync_hash();
	
	std::string fen() const;
	std::string debug_description() const;
	void display(const std::string &label = "") const;
	std::string visual() const;
	
	bool is_check(Color player) const;
	bool is_checkmate();
	bool is_win(Color player);
	bool is_alternative_winning_condition_met(Color player) const;
	bool is_stalemate();
	bool is_draw();
	bool is_finished();
	bool is_two_move_repetition() const;
	bool is_three_move_repetition() const;
	bool is_fifty_move_draw() const;
	
	template<Color PLAYER>
	void generate_quasilegal_moves_for() const;
	void generate_quasilegal_moves() const;
	
	std::vector<Move> legal_moves();
	
	template<Color PLAYER>
	Bitboard attacked_squares() const;
	
	void apply(Move move);
	void undo();
	
	bool attempt(Move move);
	
	/// Returns the color of the piece at a square. Returns `WHITE` if the square is empty.
	Color color_at_square(Bitboard B) const;
	
	bool can_castle_kingside(Color player) const;
	bool can_castle_queenside(Color player) const;
	void remove_kingside_castling_right(Color player);
	void remove_queenside_castling_right(Color player);
	
	Bitboard adjacent_squares(int square) const;
	Bitboard horizontal_vertical_span(int square) const;
	Bitboard diagonal_span(int square) const;
	Bitboard knight_span(int square) const;
	Bitboard king_span(int square) const;
	
	Move try_parse_universal(const std::string &universal) const;
	Move parse_universal(const std::string &universal) const;
	std::string universal_notation(Move move) const;
	
	Move parse_algebraic(const std::string &algebraic) const;
	
	void sanity_check() const;
	
	std::vector<int> captured_pieces(Move move) const;
};

#endif /* game_def_h */
